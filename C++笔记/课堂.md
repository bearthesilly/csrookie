# 拾遗

本笔记旨在拾遗自学过程中没有涉及到的上课的内容

## 程序框架

- Why is ``#include <stdio.h>``needed?

  - `scanf` and `printf` are declared in the standard library header file `stdio.h`.

- What does ``int main(void)``mean?

  - The `main` function is where the program starts. `int` is the return type and `void` indicates that this function accepts no arguments.

- What is the meaning of ``return 0``; ? Can it be omitted?

  - A program returns `0` if it exits successfully. The `main` function of C will execute `return 0` ***automatically at the end if we don't write it explicitly***. 

  也就是说，return 0可以省略，我们不写的话，程序跑完也会自动返回0

- How do we represent a newline?
  - `'\n'`.
- What does %d mean?
  - Indicates that the type of the data being read or printed is `int`.
- How are whitespaces handled when reading integers with scanf?
  - When reading `int` with `%d` in `scanf`, leading whitespaces are ignored.

## scanf

``scanf("%d%d", &a, &b);``  中的占位符%d：

`%d` will skip **any leading whitespaces**.

- "whitespace" refers to the character that looks "blank": space `' '`, newline `'\n`, tab `'\t'`, etc.

会跳过space 换行符 制表符

![image](png/2.png)

## variable declaration

Every variable in C has a type.

- The type is **fully deterministic** and **cannot be changed**.
- The type is known even when the program is not run
  - ⇔ The type is known at **compile-time**.  编译阶段就知道type了！
  - ⇔ C is **statically-typed** 1. ⇔ C has a **static type system**.
  - In contrast, Python is **dynamically-typed**.

“编译阶段就知道”这个东西其实是十分重要的！之后还会体提及

而变量声明在function内能声明局部变量，在任何函数体之外声明，能够声明全局变量

## Arithmetic type

八位（bit）是一个字节（byte）

### Boolean

原先一直在``<stdbool.h>``里面，而自从C23就不用加这个头文件了

在C99之前，没有true false，直接用int的1和0

### integer

那么关于整数的表示范围，假设一个整数数据类型有n bits，那么分为有符号signed 和无符号 unsigned

- If the type is **signed** 3, the range of values that can be represented is [−2^n-1,2^n-1  −1].
- If the type is **unsigned**, the range of values that can be represented is [0,2^n  −1].

因为表示符号需要最前面的数字表示正负

那么数据类型对应的字节是多少呢？ 首先我们来看命名

- The keyword `int` is optional in types other than `int`:
  - e.g. `short int` and `short` name the same type.
  - e.g. `unsigned int` and `unsigned` name the same type.
- "Unsigned-ness" needs to be written explicitly: `unsigned int`, `unsigned long`, ...
- Types without the keyword `unsigned` are signed by default:
  - e.g. `signed int` and `int` name the same type.
  - e.g. `signed long int`, `signed long`, `long int` and `long` name the same type.

unsigned不会省略，signed会； short, long, long long 其实原来都是用来修饰int的

那么占用多少字节呢？ 

![image](png/1.png)

可以发现，只有long int 类型是implementation-defined， 可能是32位也可能是64位

In addition: Implementation-defined behaviors

The standard states that the exact width of the integer types is **implementation-defined**.

- **Implementation**: The compiler and the standard library.
- An implementation-defined behavior depends on the compiler and the standard library, and is often also related to the hosted environment (e.g. the operating system).

### floating type

float : 4字节    double : 8字节   long double: 精度和范围至少比double好

float的指数范围为-127 ~ 128，而double的指数范围为-1023 ~ 1024（double更精确些）

**float和double的精度是由尾数的位数来决定的**

float：2^23 = **8388608**，一共七位，这意味着最多能有7位有效数字，但绝对能保证的为6位，也即**float的精度为6~7位有效数字**；

double：2^52 = **4503599627370496**，一共16位，同理，**double的精度为15~16位**。

无论是单精度还是双精度在存储中都分为三个部分：
**符号位(Sign) : 0代表正，1代表为负
指数位（Exponent）:用于存储科学计数法中的指数数据，并且采用移位存储
尾数部分（Mantissa）：尾数部分**

Use `double` for real floating-point arithmetic by default. Don't worry about efficiency! `double` arithmetic is not necessarily slower than `float`.

注意：不要用floating-point type于integer arithmetic, 否则返回的就是浮点数（隐式转换）

### character type

The C standard provides three **different** character types: `signed char`, `unsigned char` and `char`.

但是无论是哪一种，一定都是一个字节，四位表示范围：

signed char : -128 - 127        unsigned char : 0 - 255 (都是闭区间)

字符对应的就是ASCII码

但是值得注意的是： ***Whether `char` is signed or unsigned is implementation-defined.***

If `char` is signed (unsigned), it represents the same set of values as the type `signed char` (`unsigned char`), but **they are not the same type**. （相反，如果是short int long longlong, 那么前面加signed其实没区别）

### 隐式转换

在进行加减乘除之类的计算之前，其实都会发生一次隐形的类型转换，使得最终它们都是同一个类型

常见的有： 

If any one operand is of floating-point type and the other is an integer, **the integer will be implicitly converted to that floating-point type**. 有一个是浮点数，那么其他整数都会转化为浮点数

Similarly, if the operands are of types `int` and `long long`, the `int` value will be implicitly converted to `long long`, and the result type is `long long`.  即使都是整数，假如说一个是int 一个是long long， 那么int也会转化为long long, 最终返回值的类型也是long long  

可见，转换都会往更为严苛的方向转换

而除法就更为特殊： 

Assume `a` and `b` are of the same type `T` (after conversions as mentioned above).

- Then, the result type is also `T`.

Two cases:

- If `T` is a floating-point type, this is a floating-point division.
- If `T` is an integer type, this is an integer division. 而且结果总是向下取整！

remainder： a % b, 两个必须是相同的**整数类型**

### overflow

If a **signed integer type** holds a value that is not in the valid range, **overflow** is caused.

Suppose `int` is 32-bit and `long long` is 64-bit.

````c
int ival = 100000; long long llval = ival;
int result1 = ival * ival;               // (1) overflow , int 
long long result2 = ival * ival;         // (2) overflow , 右边算式是int, ”一瞬间“overflow
long long result3 = llval * ival;        // (3) not overflow, 右边是long long int 
long long result4 = llval * ival * ival; // (4) not overflow
````

注意，是否溢出跟右边算式有关系。看似很多都是相同的乘法，但是事实上隐式转换非常重要！

`*` is **left-associative**, so the expression `a * b * c` is interpreted as `(a * b) * c`.

但是同时一一个非常有趣的点: unsigned integers never overflow  永远会用上确界取模

## Undefined behavior

The C language standard precisely specifies the [observable behavior](https://en.cppreference.com/w/c/language/as_if) of C language programs, except for the ones in the following categories:

- *undefined behavior* - there are no restrictions on the behavior of the program. Examples of undefined behavior are **memory accesses outside of array bounds, signed integer overflow, null pointer dereference, modification of the same scalar [more than once](https://en.cppreference.com/w/c/language/eval_order) in an expression without sequence points, access to an object through a pointer of a different type, etc.** Compilers are not required to diagnose undefined behavior (although many simple situations are diagnosed), and the compiled program is not required to do anything meaningful.    ***超数组、超数据类型内存上限、空指针解引用、不同类型指针去指向一个变量、使用一个没有初始化的变量***

- *unspecified behavior* - two or more behaviors are permitted and the implementation is not required to document the effects of each behavior. For example, [order of evaluation](https://en.cppreference.com/w/c/language/eval_order), whether identical [string literals](https://en.cppreference.com/w/c/language/string_literal) are distinct, etc. Each unspecified behavior results in one of a set of valid results and may produce a different result when repeated in the same program.

- *implementation-defined behavior* - unspecified behavior where each implementation documents how the choice is made. For example, number of bits in a byte, or whether signed integer right shift is arithmetic or logical.

- *locale-specific behavior* - implementation-defined behavior that depends on the [currently chosen locale](https://en.cppreference.com/w/c/locale/setlocale). For example, whether [islower](https://en.cppreference.com/w/c/string/byte/islower) returns true for any character other than the 26 lowercase Latin letters.

(Note: [Strictly conforming](https://en.cppreference.com/w/c/language/conformance) programs do not depend on any unspecified, undefined, or implementation-defined behavior)

The compilers are required to issue diagnostic messages (either errors or warnings) for any programs that violates any C syntax rule or semantic constraint, even if its behavior is specified as undefined or implementation-defined or if the compiler provides a language extension that allows it to accept such program. Diagnostics for undefined behavior are not otherwise required.

一个好的C程序应该没有任何undefined behavior； 而undefined behavior means **"everything is possible"**

````c
i = ++i + i++; // undefined behavior
i = i++ + 1;   // undefined behavior
printf("%d, %d\n", i, i++); // undefined behavior
````

## Operator

Unless otherwise stated, the order in which the operands are evaluated is **unspecified**.

- We will see that `&&`, `||` and `?:` (and also `,`, in recitations) have specified evaluation order of their operands.

Examples: In the following expressions, it is **unspecified** whether `f` is called before `g`.

- `f() + g()`
- `f() == g()`

有上面这个结论，有： Let `A` and `B` be two expressions. **The behavior is undefined if**

- the order in which `A` and `B` are evaluated is unspecified, and  
- both `A` and `B` modify an object, or one modifies an object and the other uses its value.

``i = ++i + i++; // undefined behavior`` 因为前面后后面的表达式无法确定**谁先谁后**（不是从左到右，因为这里其实是两个函数）而这两个表达式都是尝试修改i的； 当然如果一个是改i，另一个是用i，那么也是undefined

Comparison operators are binary operators that test a condition and return `1` if that condition is logically **true** and `0` if it is logically **false**.

Note: Comparison operators in C **cannot be chained**.

Example: `a < b < c` is interpreted as `(a < b) < c` (due to left-associativity), which means to

- compare `(a < b)` first, whose result is either `0` or `1`, and then
- compare `0 < c` or `1 < c`.

## 指针与数组

小技巧：如何避免解引用空指针：

``if (ptr != NULL && *ptr == 42) { /* ... */ }`` 如果是空指针，那么右边的解引用不会进行，因为左边一判断完就知道不必再看左边了

A pointer that does not point to an existing object may be

- uninitialized (wild), or
- a null pointer, or
- dangling (We will discuss this in later lectures.), or
- holding some other meaningless address: `int *p = 123;`

Dereferencing such a pointer is **undefined behavior**, and usually causes severe **runtime errors.**

If an array is declared without explicit initialization:

- Global or local `static`: Empty-initialization ⇒ Every element is empty-initialized.
- Local non-`static`: Every element is initialized to indeterminate values (uninitialized).

````c
int main(void) {
  int a[10] = {1, 2, 3}; // a[3], a[4], ... are all initialized to zero.
  int b[100] = {0};      // All elements of b are initialized to zero.
  int c[100] = {1};      // c[0] is initialized to 1,
                         // and the rest are initialized to zero.
}
````

Nested Arrays:  (初始化有很多方法)

````c
int a[4][3] = { // array of 4 arrays of 3 ints each (4x3 matrix)
    { 1 },      // row 0 initialized to {1, 0, 0}
    { 0, 1 },   // row 1 initialized to {0, 1, 0}
    { [2]=1 },  // row 2 initialized to {0, 0, 1}
};              // row 3 initialized to {0, 0, 0}
int b[4][3] = {    // array of 4 arrays of 3 ints each (4x3 matrix)
  1, 3, 5, 2, 4, 6, 3, 5, 7 // row 0 initialized to {1, 3, 5}
};                          // row 1 initialized to {2, 4, 6}
                            // row 2 initialized to {3, 5, 7}
                            // row 3 initialized to {0, 0, 0}
int y[4][3] = {[0][0]=1, [1][1]=1, [2][0]=1};  // row 0 initialized to {1, 0, 0}
                                               // row 1 initialized to {0, 1, 0}
                                               // row 2 initialized to {1, 0, 0}
                                               // row 3 initialized to {0, 0, 0}
````

Pointer arithmetic:

![image](png/3.png)

这里p+1中的1代表的是1个字节，四位

Let `p` be a pointer of type `T *` and let `i` be an integer.

- `p + i` returns the address equal to the value of `(char *)p + i * sizeof(T)`. In other words, pointer arithmetic uses the unit of the pointed-to type.
- If we let ``p = &a[0]``(where a is an array of type T [N]), then
  - `p + i` is equivalent to `&a[i]`, and
  - `*(p + i)` is equivalent to `a[i]`.

If we let `p = &a[0]` (where `a` is an array of type `T [N]`), then

- `p + i` is equivalent to `&a[i]`, and
- `*(p + i)` is equivalent to `a[i]`.

Pointer arithmetic can only happen within the range of an array and its "past-the-end" position (indexed [0,�]). For other cases, **the behavior is undefined**.

Examples of undefined behaviors:

- `p1 - p2`, where `p1` and `p2` point to the positions of two different arrays.
- `p + 2 * N`, where `p` points to some element in an array of length `N`.
- `p - 1`, where `p` points to the first element `a[0]` of some array `a`.

Note that the evaluation of the innocent-looking expression `p - 1`, without dereferencing it, is still undefined behavior and may fail on some platforms.



Considering the close relationship between arrays and pointers, an array can be **implicitly converted** to a pointer to the first element: **`a` → `&a[0]`, `T [N]` → `T \*`**.

- `p = &a[0]` can be written as `p = a` directly.
- `*a` is equivalent to `a[0]`.  

上面就涉及到了数组指针的退化，也就涉及到了： how to pass an array to a function:

````c
void fun(int *a);
void fun(int a[]);
void fun(int a[10]);
void fun(int a[2]);
````

Return an array? Sorry, there is no way to return a n array from a function. 返回地址倒是可以，但是一定要注意：

````c
int *foo(void) {
  int a[10] = {0};
  return a;
}
````

类似于这样的事情不能发生！虽然说返回的其实是指针，但是这个数组开辟在栈区，函数调用结束，数组就释放了，那么返回的指针也就变成了野指针！解引用就undifined behavior

Pointer to array:

A pointer to an array of `N` `int`s:

```
int (*parr)[N];
```

An array of `N` pointers (pointing to `int`):

```
int *arrp[N];
```

- ``int (*parr)[N]``has a pair of parentheses around * and parr, so
  - `parr` is a pointer (`*`), and
  - points to something of type `int[N]`.
- Then the other one is different:
  - `arrp` is an array, and
  - stores `N` pointers, with pointee type `int`.

Passing a nested array to a function:

````c
void fun(int (*a)[N]); // recommanded, for its convenient format 
void fun(int a[][N]);
void fun(int a[2][N]);
void fun(int a[10][N]);
````

The parameter is of type `int (*)[N]`, which is a pointer to `int[N]`.

We can pass an array of type `int[K][N]` to `fun`, where `K` is arbitrary.

- The size for the second dimension must be N.
  - `T[10]` and `T[20]` are different types, so the pointer types `T(*)[10]` and `T(*)[20]` are not compatible.

In each of the following declarations, what is the type of `a`? Does it accept an argument of type `int[N][M]`?

1. `void fun(int a[N][M])`: A pointer to `int[M]`. Yes.
2. `void fun(int (*a)[M])`: Same as 1.
3. `void fun(int (*a)[N])`: A pointer to `int[N]`. **Yes iff `N == M`.**
4. `void fun(int **a)`: A pointer to `int *`. **No.**
5. `void fun(int *a[])`: Same as 4.
6. `void fun(int *a[N])`: Same as 4.
7. `void fun(int a[100][M])`: Same as 1.
8. `void fun(int a[N][100])`: A pointer to `int[100]`. Yes iff `M == 100`

void * 指针： A special pointer type:

- Any pointer can be implicitly converted to that type.
- A pointer of type void * can be implicitly converted to any pointer type.
  - This must happen explicitly in C++.

Use `printf("%p", ptr);` to print the value of a pointer `ptr` of type `void *`.

- If `ptr` is a pointer of some other type, a conversion is needed
- ``printf("%p", (void *)ptr);``

`void *` is often used to represent "pointer to anything", "location of some memory", or even "any object".

## Dynamic memory

Create an "array" whose size is determined at runtime? 编译阶段就需要知道数组的详细信息，包括数组元素数量和数据类型

- **We need a block of memory, the size of which can be determined at runtime.**
- If we run out of memory, **we need to know**.
- We may require a pretty large chunk of memory.

### Using malloc and free and calloc

Declared in `<stdlib.h>`.

```
void *malloc(size_t size);
```

Allocates `size` bytes of uninitialized storage on heap.

If allocation succeeds, returns the starting address of the allocated memory block.

If allocation fails, a null pointer is returned.

- size_t:  A type that can hold the size (number of bytes) of any object. It is
  - declared in `<stddef.h>`, and
  - is an **unsigned** integer type,
  - whose size is implementation-defined. For example, it may be 64-bit on a 64-bit machine, and 32-bit on a 32-bit machine.

````c 
T *ptr = malloc(sizeof(T) * n); // sizeof(T) * n bytes
for (int i = 0; i != n; ++i)
  ptr[i] = /* ... */
// Now you can use `ptr` as if it points to an array of `n` objects of type `T`
// ...
free(ptr); // to avoid memory leak 
````

In addition: There is no need to do a null check before calling `free`!（如果是空指针，free函数不会做任何事情）

重点！重复释放是一种Undefined behavior

Create a "2-d array" on heap?

````c
int **p = malloc(sizeof(int *) * n);
for (int i = 0; i < n; ++i)
  p[i] = malloc(sizeof(int) * m); // p已经能当数组用了；p中每一个元素是一个地址；这句话使得地址指向的也是一个“数组”
for (int i = 0; i < n; ++i)
  for (int j = 0; j < m; ++j)
    p[i][j] = /* ... */   // 已经能当二维数组使用指针了
// ...
for (int i = 0; i < n; ++i)
  free(p[i]);
free(p); // 释放也是逐级释放
````

但是也需要注意：要释放就整体完全释放，不能只释放一部分

C 库函数 **void \*calloc(size_t nitems, size_t size)** 分配所需的内存空间，并返回一个指向它的指针。**malloc** 和 **calloc** 之间的不同点是，malloc 不会设置内存为零，而 calloc 会设置分配的内存为零。

``void *calloc(size_t nitems, size_t size)``, 参数第一个是分配的元素个数，第二个是元素的大小；该函数返回一个指针，指向已分配的内存。如果请求失败，则返回 NULL。

## String

C does not have a special construct for "string".

A string is a sequence of characters stored contiguously. We often use an array or a pointer to the first character to represent a string.

- It can be stored in an array, or in dynamically allocated memory.
- **It must be null-terminated: There should be a null character `'\0'` at the end.**

````c
char s[10] = "abcde";  // s = {'a', 'b', 'c', 'd', 'e', '\0'}
printf("%s\n", s);     // prints abcde
printf("%s\n", s + 1); // prints bcde , +1代表全体前移一位后的结果，a扔掉了
s[2] = ';';            // s = "ab;de"
printf("%s\n", s);     // prints ab;de
s[2] = '\0';
printf("%s\n", s);     // prints ab
````

第三行其实是一个小技巧，解体中可能会使用

The position of the first `'\0'` is the end of the string. **Anything after that is discarded.**

Every standard library function that handles strings will search for `'\0'` in that string.

- If there is no `'\0'`, they will search nonstop, and eventually go out of range (undefined behavior).

````c
char s[5] = "abcde"; // OK, but no place for '\0'.
printf("%s\n", s);   // undefined behavior (missing '\0')
````

[`scanf`](https://en.cppreference.com/w/c/io/fscanf)/[`printf`](https://en.cppreference.com/w/c/io/fprintf): `"%s"`

- %s in scanf matches a sequence of non-whitespace characters.

- Leading whitespaces are discarded. // 开头的''空格''（whitespace）都省略掉
- Reading starts from the first non-whitespace character, and stops right before the next whitespace character. // 在下一个whitespace停止读取
- `'\0'` will be placed at the end. // 而且最后会将一个/0**紧接着读取内容被读取进去**（见下例）

Suppose the input is `   123  456`:

````c
char str[100] = "abcdef";
scanf("%s", str); // Reads "123". `str` becomes {'1', '2', '3', '\0', 'e', 'f'}
printf("%s\n", str); // Prints "123".
                     // 'e' and 'f' are not considered as part of the string.
````

上面这种读法明显太麻烦而且害怕超上限

`gets` reads a string without bounds checking. **It has been removed since C11.**

- An alternative for `gets` that does bounds checking is `gets_s`, but not supported by every compiler.

**The best alternative: [`fgets`](https://en.cppreference.com/w/c/io/fgets).** It is more portable, more generic, and **safer (with bounds checking).**

```c
char str[100];
fgets(str, 100, stdin);
```

`**puts(str)**`: Prints the string `str`, followed by a newline.



***String manipulation / examination***

Some common standard library functions: declared in `<string.h>`.

- `strlen(str)`: Returns the length of the string `str`.
- `strcpy(dest, src)`: Copies the string `src` to `dest`.
- `strcat(dest, src)`: Appends a copy of `src` to the end of `dest`.
- `strcmp(s1, s2)`: Compares two strings in lexicographical order.
- `strchr(str, ch)`: Finds the first occurrence of `ch` in `str`.

**This page is only a brief introduction which cannot be relied on.** The detailed documentations can be found [here](https://en.cppreference.com/w/c/string/byte).

更多函数细节见下：



Implement your own `strlen`, which accepts a pointer to the first character of a string and returns its length.

````c
size_t my_strlen(const char *str) { // const加入是为了保证不对输入的string进行改变
  size_t ans = 0; // 当作指针对待
  while (*str != '\0') { // 解引用后发现不是'\0'
    ++ans;
    ++str; // 这里自动加的就是数据类型的字节数
  }
  return ans;
}
````

````c
size_t my_strlen(const char *str) {
  const char *end = str; // 当作数组对待，用一个指针指向它
  while (*end != '\0')
    ++end;
  return end - str; // 解引用后发现是'\0'的地址减去首地址，又由于char内存是1字节
}
````

````c
size_t my_strlen(const char *str) {
  size_t ans = 0;
  while (*str++ != '\0') // Understand and learn to use this.
    ++ans; // 注意是先str后++，指的是先判断，然后再地址+1
  return ans;
}
````

如果想要一个指针指向string, 那么最好用const char *, 因为string的字符串类型其实是const char

Using a pointer to non-`const` to point to a string literal is **allowed in C** (not allowed in C++), but **very dangerous**:

````c
char *p = "abcde"; // OK
p[3] = 'a'; // No compile-error, but undefined behavior,
            // and possibly severe runtime-error.
````

Correct ways: Use low-level `const`ness to protect it:

````c
const char *str = "abcde";
str[3] = 'a'; // compile-error
````

Or : Copy the content into an array instead of using a pointer pointing to it 

````c
char arr[] = "abcde";
arr[3] = 'a'; // OK.
// `arr` contains a copy of "abcde".
````



***Array of strings*** 

````c
const char *translations[] = {
  "zero", "one", "two", "three", "four",
  "five", "six", "seven", "eight", "nine"
};
````

- `translations` is an array of pointers, where each pointer points to a string literal.
- `translations` **is not a 2-d array!**

![image](png/4.png)



Summary:

A C-style string is a sequence of characters stored contiguously, with `'\0'` at the end.

- Never forget the null character `'\0'`.
- String literals are not modifiable, even though their types are not const
  - It's better to use a pointer to `const` to point to a string literal.
- I/O: `scanf`/`printf`, `fgets`, `puts`
- String manipulation / examination functions like `strlen`, `strcmp`, `strcpy`, ...
- Conversions to and from numeric formats: `strtol`, `strtoll`, ...





